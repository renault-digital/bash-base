.\" Automatically generated by Pandoc 2.10
.\"
.TH "" "1" "" "" "bash-base functions reference"
.hy
.SS NAME
.PP
string_trim \[en] remove the white chars from prefix and suffix
.SS SYNOPSIS
.IP
.nf
\f[C]
string_trim [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_trim \[dq] as fd \[dq]
string_trim < logfile
echo \[dq] add \[dq] | string_trim
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
string_repeat \[en] make a string by repeat n times of a token string
.SS SYNOPSIS
.IP
.nf
\f[C]
string_repeat string [nbTimes]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]string\f[R] the string to be repeated
.IP \[bu] 2
\f[B][nbTimes]\f[R] the number of times, if absent, it will be read from
the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_repeat \[aq]abc\[aq] 5
echo 5 | string_repeat \[aq]abc\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
string_length \[en] return the string length
.SS SYNOPSIS
.IP
.nf
\f[C]
string_length [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_length \[dq] as fd \[dq]
string_length < logfile
echo \[dq] add \[dq] | string_length
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
string_is_empty \[en] exit success code 0 if the string is empty
.SS SYNOPSIS
.IP
.nf
\f[C]
string_is_empty [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_is_empty \[dq] as fd \[dq]
string_is_empty < logfile
echo \[dq] add \[dq] | string_is_empty
\f[R]
.fi
.SS SEE_ALSO
.PP
string_length
.PP
   *   *   *   *   *
.SS NAME
.PP
string_revert \[en] revert the characters of a string
.SS SYNOPSIS
.IP
.nf
\f[C]
string_revert [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to be reverted, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_revert \[aq]aBc\[aq]
echo \[aq]aBc\[aq] | string_revert
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
string_upper \[en] convert all characters to upper case
.SS SYNOPSIS
.IP
.nf
\f[C]
string_upper [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to be converted, if absent, it will be
read from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_upper \[aq]abc\[aq]
echo \[aq]abc\[aq] | string_upper
\f[R]
.fi
.SS SEE_ALSO
.PP
string_upper_first, string_lower
.PP
   *   *   *   *   *
.SS NAME
.PP
string_lower \[en] convert all characters to lower case
.SS SYNOPSIS
.IP
.nf
\f[C]
string_lower [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to be converted, if absent, it will be
read from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_lower \[aq]aBc\[aq]
echo \[aq]aBc\[aq] | string_lower
\f[R]
.fi
.SS SEE_ALSO
.PP
string_upper, string_upper_first
.PP
   *   *   *   *   *
.SS NAME
.PP
string_upper_first \[en] convert the first characters to upper case, and
the others to lower case
.SS SYNOPSIS
.IP
.nf
\f[C]
string_upper_first [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B][string]\f[R] the string to be converted, if absent, it will be
read from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_upper_first \[aq]aBc\[aq]
echo \[aq]aBc\[aq] | string_upper_first
\f[R]
.fi
.SS SEE_ALSO
.PP
string_lower, string_upper
.PP
   *   *   *   *   *
.SS NAME
.PP
string_sub \[en] extract a part of string and return
.SS SYNOPSIS
.IP
.nf
\f[C]
string_sub startIndex subStringLength [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]startIndex\f[R] the index of first character in string, 0 based,
may negative
.IP \[bu] 2
\f[B]subStringLength\f[R] the length of sub string, 0 based, may
negative
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_sub -5 -1 \[dq] as fd \[dq]
string_sub 3 5 < temp_file.txt
echo \[aq] as fd \[aq] | string_sub 2 4
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
string_match \[en] test if the string match the regular expression
.SS SYNOPSIS
.IP
.nf
\f[C]
string_match regExp [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]regExp\f[R] the regular expression
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_match \[aq]name;+\[aq] \[dq]name;name;\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_index_first
.PP
   *   *   *   *   *
.SS NAME
.PP
escape_sed \[en] escape preserved char of regex, normally for
preprocessing of sed token.
.SS SYNOPSIS
.IP
.nf
\f[C]
escape_sed string
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]string\f[R] the string to process
.SS EXAMPLES
.IP
.nf
\f[C]
escape_sed \[aq]a$\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_replace
.PP
   *   *   *   *   *
.SS NAME
.PP
string_replace \[en] replace literally the token string to new string,
not support regular expression
.SS SYNOPSIS
.IP
.nf
\f[C]
string_replace tokenString newString [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the string to search, the preserved character of
regular expression will be escaped
.IP \[bu] 2
\f[B]newString\f[R] the new value of replacing to, the preserved
character of regular expression will be escaped
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_replace \[aq]a\[aq] \[aq]b\[aq] \[aq]aaa\[aq]   ==> \[aq]bbb\[aq]
string_replace \[aq]$\[aq] \[aq]b\[aq] \[aq]a$a\[aq]   ==> \[aq]aba\[aq]
string_replace \[aq]\[rs]*\[aq] \[aq]b\[aq] \[aq]a*a\[aq]  ==> \[aq]aba\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
escape_sed, string_replace_regex
.PP
   *   *   *   *   *
.SS NAME
.PP
string_replace_regex \[en] replace the token string to new string,
support regular expression
.SS SYNOPSIS
.IP
.nf
\f[C]
string_replace_regex tokenString newString [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the string to search, support regular expression
and its modern extension
.IP \[bu] 2
\f[B]newString\f[R] the new value of replacing to, support
back-references (https://www.gnu.org/software/sed/manual/html_node/Back_002dreferences-and-Subexpressions.html)
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_replace_regex \[aq]a*\[aq] \[aq]b\[aq] \[aq]a*a\[aq] ==> \[aq]b*b\[aq]
string_replace_regex \[aq]a*\[aq] \[aq]b\[aq] \[dq]aaa\[dq] ==> \[aq]b\[aq]
string_replace_regex \[aq]*\[aq] \[aq]b\[aq] \[aq]a*a\[aq]  ==> \[aq]aba\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_replace
.PP
   *   *   *   *   *
.SS NAME
.PP
string_index_first \[en] return the positive index of first place of
token in string, -1 if not existed
.SS SYNOPSIS
.IP
.nf
\f[C]
string_index_first tokenString [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the string to search
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_index_first \[dq]s f\[dq] \[dq] as fd \[dq]
string_index_first \[dq]token\[dq] < logfile
echo \[dq] add \[dq] | string_index_first \[dq]token\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_before_first, string_after_first
.PP
   *   *   *   *   *
.SS NAME
.PP
string_before_first \[en] find the first index of token in string, and
return the sub string before it.
.SS SYNOPSIS
.IP
.nf
\f[C]
string_before_first tokenString [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the string to search
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_before_first \[dq]s f\[dq] \[dq] as fd \[dq]
string_before_first \[dq]str\[dq] < logfile
echo \[dq] add \[dq] | string_before_first \[dq]dd\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_index_first, string_after_first
.PP
   *   *   *   *   *
.SS NAME
.PP
string_after_first \[en] find the first index of token in string, and
return the sub string after it.
.SS SYNOPSIS
.IP
.nf
\f[C]
string_after_first tokenString [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the string to search
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
string_after_first \[dq]s f\[dq] \[dq] as fd \[dq]
string_after_first \[dq]str\[dq] < logfile
echo \[dq] add \[dq] | string_after_first \[dq]dd\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_index_first, string_before_first
.PP
   *   *   *   *   *
.SS NAME
.PP
string_split_to_array \[en] split a string to array by a delimiter
character, then assign the array to a new variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
string_split_to_array tokenString [newArrayVarName] [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]tokenString\f[R] the delimiter string
.IP \[bu] 2
\f[B][newArrayVarName]\f[R] optional, the variable name of result array,
if absent, the mapped array will be joined by newline and printed to
stdout
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
str=\[dq]a|b|c\[dq]
string_split_to_array \[aq]|\[aq] newArray \[dq]$str\[dq]

branchesToSelectString=$(git branch -r --list  \[aq]origin/*\[aq])
string_split_to_array $\[aq]
\[aq] branchesToSelectArray \[dq]${branchesToSelectString}\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
array_join, array_describe, array_from_describe, string_pick_to_array
.PP
   *   *   *   *   *
.SS NAME
.PP
string_pick_to_array \[en] take value using start token and end token
from a string to array, then assign the array to a new variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
string_pick_to_array startTokenString endTokenString [newArrayVarName] [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]startTokenString\f[R] the start token string
.IP \[bu] 2
\f[B]endTokenString\f[R] the end token string
.IP \[bu] 2
\f[B][newArrayVarName]\f[R] optional, the variable name of result array,
if absent, the mapped array will be joined by newline and printed to
stdout
.IP \[bu] 2
\f[B][string]\f[R] the string to process, if absent, it will be read
from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
str=\[dq][{age:12},{age:15},{age:16}]\[dq]
string_pick_to_array \[aq]{age:\[aq] \[aq]}\[aq] newArray \[dq]$str\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
array_join, array_describe, array_from_describe, string_split_to_array
.PP
   *   *   *   *   *
.SS NAME
.PP
array_join \[en] join an array to string using delimiter string
.SS SYNOPSIS
.IP
.nf
\f[C]
array_join delimiter arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]delimiter\f[R] the delimiter string
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArry=(\[dq] a \[dq] \[dq] b c \[dq])
array_join \[aq]|\[aq] myArry ==> \[dq] a | b c \[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
string_split_to_array, array_describe, array_from_describe
.PP
   *   *   *   *   *
.SS NAME
.PP
array_describe \[en] convert the array to its string representation
.SS SYNOPSIS
.IP
.nf
\f[C]
array_describe arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=(\[dq]a\[dq] \[dq]b\[dq])
array_describe myArray ==> ([0]=\[aq]a\[aq] [1]=\[aq]b\[aq])
\f[R]
.fi
.SS SEE_ALSO
.PP
string_split_to_array, array_join, array_from_describe
.PP
   *   *   *   *   *
.SS NAME
.PP
array_from_describe \[en] restore the array from its string
representation, then assign it to a variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_from_describe newArrayVarName [string]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]newArrayVarName\f[R] the new variable name which the array will be
assigned to
.IP \[bu] 2
\f[B][string]\f[R] the string of array describe, if absent, it will be
read from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
array_from_describe myNewArray \[dq]([0]=\[aq]a\[aq] [1]=\[aq]b\[aq])\[dq]
array_from_describe myNewArray < fileNameContentString
\f[R]
.fi
.SS SEE_ALSO
.PP
string_split_to_array, array_join, array_describe
.PP
   *   *   *   *   *
.SS NAME
.PP
array_contains \[en] exit success code 0 if array contains element, fail
if not.
.SS SYNOPSIS
.IP
.nf
\f[C]
array_contains arrayVarName [seekingElement]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to test
.IP \[bu] 2
\f[B][seekingElement]\f[R] the element to search in array, if absent, it
will be read from the standard input (CTRL+D to end)
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]ab\[dq] \[dq]f\[dq] \[dq]g\[dq])
array_contains arr \[dq]ab\[dq]
echo \[dq]ab\[dq] | array_contains arr
\f[R]
.fi
.SS SEE_ALSO
.PP
array_remove
.PP
   *   *   *   *   *
.SS NAME
.PP
array_sort \[en] sort the elements of array, save the result to original
variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_sort arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=(\[aq]aa\[aq] \[aq]bb\[aq] \[aq]aa\[aq])
array_sort myArray ==> ([0]=\[aq]aa\[aq] [1]=\[aq]aa\[aq] [2]=\[aq]bb\[aq])
\f[R]
.fi
.SS SEE_ALSO
.PP
array_sort_distinct
.PP
   *   *   *   *   *
.SS NAME
.PP
array_sort_distinct \[en] remove the duplicated elements of array, sort
and save the result to original variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_sort_distinct arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=(\[aq]aa\[aq] \[aq]bb\[aq] \[aq]aa\[aq])
array_sort_distinct myArray ==> ([0]=\[aq]aa\[aq] [1]=\[aq]bb\[aq])
\f[R]
.fi
.SS SEE_ALSO
.PP
array_sort
.PP
   *   *   *   *   *
.SS NAME
.PP
array_length \[en] return the number of elements of array
.SS SYNOPSIS
.IP
.nf
\f[C]
array_length arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=(\[aq]aa\[aq] \[aq]bb\[aq] \[aq]aa\[aq])
array_length myArray ==> 3
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
array_reset_index \[en] reset the indexes of array to the sequence
0,1,2\&..., save the result to original variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_reset_index arrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of the array to be processed
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=([2]=\[aq]a\[aq] [5]=\[aq]c\[aq] [11]=\[aq]dd\[aq])
array_reset_index myArray ==> ([0]=\[aq]a\[aq] [1]=\[aq]c\[aq] [2]=\[aq]dd\[aq])
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
array_equals \[en] test if the elements of 2 array are equal, ignore the
array index
.SS SYNOPSIS
.IP
.nf
\f[C]
array_equals arrayVarName1 arrayVarName2 [ignoreOrder] [ignoreDuplicated]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName1\f[R] the variable name of an array
.IP \[bu] 2
\f[B]arrayVarName2\f[R] the variable name of another array to compare
with
.IP \[bu] 2
\f[B][ignoreOrder]\f[R] optional, a boolean value true/false, indicate
whether ignore element order when compare, default true
.IP \[bu] 2
\f[B][ignoreDuplicated]\f[R] optional, a boolean value true/false,
indicate whether ignore element duplicated when compare, default false
.SS EXAMPLES
.IP
.nf
\f[C]
myArray1=(\[aq]aa\[aq] [3]=\[aq]bb\[aq] \[aq]aa\[aq])
myArray2=(\[aq]aa\[aq] \[aq]aa\[aq] \[aq]bb\[aq])
array_equals myArray1 myArray2 false && echo Y || echo N ==> N
array_equals myArray1 myArray2 true && echo Y || echo N ==> Y
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
array_intersection \[en] calcul the intersection of 2 arrays, and save
the result to a new variable
.SS SYNOPSIS
.IP
.nf
\f[C]
array_intersection arrayVarName1 arrayVarName2 newArrayVarName [ignoreOrderAndDuplicated]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName1\f[R] the variable name of an array
.IP \[bu] 2
\f[B]arrayVarName2\f[R] the variable name of another array
.IP \[bu] 2
\f[B]newArrayVarName\f[R] the name of new variable to save the result
.IP \[bu] 2
\f[B][ignoreOrderAndDuplicated]\f[R] optional, a boolean value
true/false, indicate whether ignore element duplicated and order them
when save the result, default true
.SS EXAMPLES
.IP
.nf
\f[C]
myArray1=(\[aq]aa\[aq] [3]=\[aq]bb\[aq] \[aq]aa\[aq] \[aq]cc\[aq])
myArray2=(\[aq]aa\[aq] \[aq]aa\[aq] \[aq]dd\[aq] \[aq]bb\[aq])
array_intersection myArray1 myArray2 newArray
array_intersection myArray1 myArray2 newArray false
\f[R]
.fi
.SS SEE_ALSO
.PP
array_subtract, array_union
.PP
   *   *   *   *   *
.SS NAME
.PP
array_subtract \[en] calcul the subtract of 2 arrays, and save the
result to a new variable
.SS SYNOPSIS
.IP
.nf
\f[C]
array_subtract arrayVarName1 arrayVarName2 newArrayVarName [ignoreOrderAndDuplicated]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName1\f[R] the variable name of an array
.IP \[bu] 2
\f[B]arrayVarName2\f[R] the variable name of another array
.IP \[bu] 2
\f[B]newArrayVarName\f[R] the name of new variable to save the result
.IP \[bu] 2
\f[B][ignoreOrderAndDuplicated]\f[R] optional, a boolean value
true/false, indicate whether ignore element duplicated and order them
when save the result, default true
.SS EXAMPLES
.IP
.nf
\f[C]
myArray1=(\[aq]aa\[aq] [3]=\[aq]bb\[aq] \[aq]aa\[aq] \[aq]cc\[aq])
myArray2=(\[aq]aa\[aq] \[aq]aa\[aq] \[aq]dd\[aq] \[aq]bb\[aq])
array_subtract myArray1 myArray2 newArray
array_subtract myArray1 myArray2 newArray false
\f[R]
.fi
.SS SEE_ALSO
.PP
array_intersection, array_union
.PP
   *   *   *   *   *
.SS NAME
.PP
array_union \[en] calcul the union of 2 arrays, and save the result to a
new variable
.SS SYNOPSIS
.IP
.nf
\f[C]
array_union arrayVarName1 arrayVarName2 newArrayVarName [ignoreOrderAndDuplicated]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName1\f[R] the variable name of an array
.IP \[bu] 2
\f[B]arrayVarName2\f[R] the variable name of another array
.IP \[bu] 2
\f[B]newArrayVarName\f[R] the name of new variable to save the result
.IP \[bu] 2
\f[B][ignoreOrderAndDuplicated]\f[R] optional, a boolean value
true/false, indicate whether ignore element duplicated and order them
when save the result, default true
.SS EXAMPLES
.IP
.nf
\f[C]
myArray1=(\[aq]aa\[aq] [3]=\[aq]bb\[aq] \[aq]aa\[aq] \[aq]cc\[aq])
myArray2=(\[aq]aa\[aq] \[aq]aa\[aq] \[aq]dd\[aq] \[aq]bb\[aq])
array_union myArray1 myArray2 newArray
array_union myArray1 myArray2 newArray false
\f[R]
.fi
.SS SEE_ALSO
.PP
array_intersection, array_union
.PP
   *   *   *   *   *
.SS NAME
.PP
array_append \[en] append some elements to original array
.SS SYNOPSIS
.IP
.nf
\f[C]
array_append arrayVarName element...
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to process
.IP \[bu] 2
\f[B]element\&...\f[R] the elements to append to array
.SS EXAMPLES
.IP
.nf
\f[C]
myArray=()
array_append myArray \[dq]ele ment1\[dq] \[dq]ele ment2\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
array_remove
.PP
   *   *   *   *   *
.SS NAME
.PP
array_remove \[en] remove the element from the original array
.SS SYNOPSIS
.IP
.nf
\f[C]
array_remove arrayVarName element
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to process
.IP \[bu] 2
\f[B]element\f[R] the element to remove from array
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]ab\[dq] \[dq]f\[dq] \[dq]g\[dq])
array_remove arr \[dq]ab\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
array_contains, array_append
.PP
   *   *   *   *   *
.SS NAME
.PP
array_clone \[en] clone an array, including
index/order/duplication/value, and assign the result array to a new
variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_clone arrayVarName newArrayVarName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to process
.IP \[bu] 2
\f[B]newArrayVarName\f[R] the variable name of result array
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq] a \[dq] \[dq] b c \[dq])
array_clone arr newArray
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
array_map \[en] apply the specified map operation on each element of
array, and assign the result array to a new variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_map arrayVarName pipedOperators [newArrayVarName]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to process
.IP \[bu] 2
\f[B]pipedOperators\f[R] a string of operations, if multiple operations
will be apply on each element, join them by pipe `|'
.IP \[bu] 2
\f[B][newArrayVarName]\f[R] optional, the variable name of result array,
if absent, the mapped array will be joined by newline and printed to
stdout
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq] a \[dq] \[dq] b c \[dq])
array_map arr \[dq]string_trim | wc -m | string_trim\[dq] newArray
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
array_filter \[en] filter the elements of an array, and assign the
result array to a new variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
array_filter arrayVarName regExp [newArrayVarName]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array to process
.IP \[bu] 2
\f[B]regExp\f[R] a string of regular expression pattern
.IP \[bu] 2
\f[B][newArrayVarName]\f[R] optional, the variable name of result array,
if absent, the mapped array will be joined by newline and printed to
stdout
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq]NAME A\[dq] \[dq]NAME B\[dq] \[dq]OTHER\[dq])
array_filter arr \[aq]NAME\[aq] newArray
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
args_parse \[en] parse the script argument values to positional variable
names, process firstly the optional param help(-h) / quiet(-q) if
existed
.SS SYNOPSIS
.IP
.nf
\f[C]
args_parse $# \[dq]$##### \[dq] positionalVarName...
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]positionalVarName\&...\f[R] some new variable names to catch the
positional argument values
.SS EXAMPLES
.IP
.nf
\f[C]
args_parse $# \[dq]$##### \[dq] newVar1 newVar2 newVar3
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
args_valid_or_select \[en] test whether the value contains by the array,
if not contained, require to select a new one from array and assign it
to the value variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
args_valid_or_select valueVarName arrayVarName prompt
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]valueVarName\f[R] the variable name of the value to valid and the
new value assign to,
.IP \[bu] 2
\f[B]arrayVarName\f[R] the variable name of array
.IP \[bu] 2
\f[B]prompt\f[R] the prompt message to show when requiring to select a
new one from array
.SS EXAMPLES
.IP
.nf
\f[C]
arr=(\[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]ab\[dq] \[dq]f\[dq] \[dq]g\[dq])
appName=\[dq]abc\[dq]
args_valid_or_select appName arr \[dq]Which app\[dq]
varEmpty=\[dq]\[dq]
args_valid_or_select varEmpty arr \[dq]Which app\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
args_valid_or_select_pipe, args_valid_or_read
.PP
   *   *   *   *   *
.SS NAME
.PP
args_valid_or_select_pipe \[en] test whether the value contains by the
array, if not contained, require to select a new one from array and
assign it to the value variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
args_valid_or_select_pipe valueVarName strValidValues prompt
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]valueVarName\f[R] the variable name of the value to valid and the
new value assign to,
.IP \[bu] 2
\f[B]strValidValues\f[R] values joined by pipe `|'
.IP \[bu] 2
\f[B]prompt\f[R] the prompt message to show when requiring to select a
new one from array
.SS EXAMPLES
.IP
.nf
\f[C]
sel=\[dq]abc\[dq]
args_valid_or_select_pipe sel \[dq]a|ab|d\[dq] \[dq]which value\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
args_valid_or_select, args_valid_or_read
.PP
   *   *   *   *   *
.SS NAME
.PP
args_valid_or_read \[en] test whether the value matched the valid
regular expression, if not matched, require input a new one and assign
it to the value variable name
.SS SYNOPSIS
.IP
.nf
\f[C]
args_valid_or_read valueVarName strRegExp prompt [proposedValue]
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]valueVarName\f[R] the variable name of the value to valid and the
new value assign to,
.IP \[bu] 2
\f[B]strRegExp\f[R] a string of regular expression to be used for
validation
.IP \[bu] 2
\f[B]prompt\f[R] the prompt message to show when requiring to read a new
one from stdin
.IP \[bu] 2
\f[B][proposedValue]\f[R] the proposed spare value to show for user, or
to used when quite mode
.SS EXAMPLES
.IP
.nf
\f[C]
args_valid_or_read destProjectSIA \[aq]\[ha][0-9a-z]{3,3}$\[aq] \[dq]SIA (lowercase, 3 chars)\[dq]
args_valid_or_read destProjectIRN \[aq]\[ha][0-9]{5,5}$\[aq] \[dq]IRN (only the 5 digits)\[dq]
args_valid_or_read destRootPackage \[aq]\[ha].+$\[aq] \[dq]Destination root package\[dq] \[dq]${defaultDestRootPackage}\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
args_valid_or_select, args_valid_or_select_pipe
.PP
   *   *   *   *   *
.SS NAME
.PP
args_print \[en] show the name and value of variables
.SS SYNOPSIS
.IP
.nf
\f[C]
args_print variableName...
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]variableName\&...\f[R] some existed variable names to show its
value
.SS EXAMPLES
.IP
.nf
\f[C]
var1=\[dq]value 1\[dq]
var2=\[dq]value 2\[dq]
args_print var1 var2
\f[R]
.fi
.SS SEE_ALSO
.PP
args_confirm
.PP
   *   *   *   *   *
.SS NAME
.PP
args_confirm \[en] show the name and value of variables, and continue
execute if confirmed by user, or exit if not
.SS SYNOPSIS
.IP
.nf
\f[C]
args_confirm variableName...
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]variableName\&...\f[R] some existed variable names to show its
value
.SS EXAMPLES
.IP
.nf
\f[C]
a=\[dq]correct value\[dq]
b=\[dq]wrong value\[dq]
args_confirm a b
\f[R]
.fi
.SS SEE_ALSO
.PP
args_print
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_nth_arg \[en] parse a string of arguments, then extract the nth
argument
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_nth_arg index arguments...
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]index\f[R] a number based on 1, which argument to extract
.IP \[bu] 2
\f[B]arguments\&...\f[R] the string to parse, the arguments and may also
including the command.
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_nth_arg 3 ab cdv \[dq]ha ho\[dq] ==>  \[dq]ha ho\[dq]

string=\[dq]args_valid_or_read myVar \[aq]\[ha][0-9a-z]{3,3}$\[aq] \[rs]\[dq]SIA\[rs]\[dq]\[dq]
reflect_nth_arg 4 $string ==> \[dq]SIA\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_get_function_definition \[en] print the definition of the
specified function in system
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_get_function_definition functionName
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]functionName\f[R] the specified function name
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_get_function_definition args_confirm
\f[R]
.fi
.SS SEE_ALSO
.PP
reflect_function_names_of_file
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_function_names_of_file \[en] print the function names defined in
a shell script file
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_function_names_of_file shellScriptFile
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]shellScriptFile\f[R] the path of shell script file
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_function_names_of_file $0
reflect_function_names_of_file scripts/my_script.sh
\f[R]
.fi
.SS SEE_ALSO
.PP
reflect_get_function_definition
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_function_definitions_of_file \[en] print the function
definitions defined in a shell script file
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_function_definitions_of_file shellScriptFile
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]shellScriptFile\f[R] the path of shell script file
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_function_definitions_of_file $0
reflect_function_definitions_of_file scripts/my_script.sh
\f[R]
.fi
.SS SEE_ALSO
.PP
reflect_get_function_definition
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_search_function \[en] search usable function by name pattern
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_search_function functionNamePattern
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]functionNamePattern\f[R] the string of function name regular
expression pattern
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_search_function args
reflect_search_function \[aq]\[ha]args_.*\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
reflect_search_variable
.PP
   *   *   *   *   *
.SS NAME
.PP
reflect_search_variable \[en] search usable variable by name pattern
.SS SYNOPSIS
.IP
.nf
\f[C]
reflect_search_variable variableNamePattern
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]variableNamePattern\f[R] the string of variable name regular
expression pattern
.SS EXAMPLES
.IP
.nf
\f[C]
reflect_search_variable COLOR
reflect_search_variable \[aq]\[ha]COLOR\[aq]
\f[R]
.fi
.SS SEE_ALSO
.PP
reflect_search_function
.PP
   *   *   *   *   *
.SS NAME
.PP
doc_lint_script_comment \[en] format the shell script, and check whether
the comment is corrected man-styled
.SS SYNOPSIS
.IP
.nf
\f[C]
doc_lint_script_comment shellScriptFile
\f[R]
.fi
.SS DESCRIPTION
.PP
It\[cq]s better format your shell script by \f[C]shfmt\f[R] firstly
before using this function.
.IP \[bu] 2
\f[B]shellScriptFile\f[R] the path of shell script file
.SS EXAMPLES
.IP
.nf
\f[C]
shellScriptFile=\[dq]src/bash-base.sh\[dq]
docker run -it --rm -v \[dq]$(pwd):/src\[dq] -w /src mvdan/shfmt -l -w \[dq]${shellScriptFile}\[dq]
doc_lint_script_comment \[dq]${shellScriptFile}\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
doc_comment_to_markdown, doc_markdown_to_manpage
.PP
   *   *   *   *   *
.SS NAME
.PP
doc_comment_to_markdown \[en] convert the shell script man-styled
comment to markdown file
.SS SYNOPSIS
.IP
.nf
\f[C]
doc_comment_to_markdown fromShellFile toMarkdownFile
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]fromShellFile\f[R] the path of source shell script file
.IP \[bu] 2
\f[B]toMarkdownFile\f[R] the path of destination markdown file
.SS EXAMPLES
.IP
.nf
\f[C]
doc_comment_to_markdown src/bash-base.sh docs/reference.md
\f[R]
.fi
.SS SEE_ALSO
.PP
doc_markdown_to_manpage, doc_check_script_comment
.PP
   *   *   *   *   *
.SS NAME
.PP
print_header \[en] print the header value with prefix \[cq] ###\[cq] and
bold font
.SS SYNOPSIS
.IP
.nf
\f[C]
print_header string
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]string\f[R] the string of header title
.SS EXAMPLES
.IP
.nf
\f[C]
print_header \[dq]My header1\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
print_error
.PP
   *   *   *   *   *
.SS NAME
.PP
print_error \[en] print the error message with prefix `ERROR:' and font
color red
.SS SYNOPSIS
.IP
.nf
\f[C]
print_error string
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]string\f[R] the error message
.SS EXAMPLES
.IP
.nf
\f[C]
print_error \[dq]my error message\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
print_header
.PP
   *   *   *   *   *
.SS NAME
.PP
stop_if_failed \[en] stop the execute if last command exit with fail
code (no zero)
.SS SYNOPSIS
.IP
.nf
\f[C]
stop_if_failed string
\f[R]
.fi
.SS DESCRIPTION
.PP
`trap' or `set -e' is not recommended - \f[B]string\f[R] the error
message to show
.SS EXAMPLES
.IP
.nf
\f[C]
rm -fr \[dq]${destProjectPath}\[dq]
stop_if_failed \[dq]ERROR: can\[aq]t delete the directory \[aq]${destProjectPath}\[aq] !\[dq]
\f[R]
.fi
.SS SEE_ALSO
.PP
   *   *   *   *   *
.SS NAME
.PP
declare_heredoc \[en] stop the execute if last command exit with fail
code (no zero)
.SS SYNOPSIS
.IP
.nf
\f[C]
declare_heredoc newVarName <<-EOF
\&...
EOF
\f[R]
.fi
.SS DESCRIPTION
.IP \[bu] 2
\f[B]newVarName\f[R] the variable name, the content of heredoc will be
assigned to it
.SS EXAMPLES
.IP
.nf
\f[C]
declare_heredoc records <<-EOF
record1
record2
EOF
\f[R]
.fi
.SS SEE_ALSO
